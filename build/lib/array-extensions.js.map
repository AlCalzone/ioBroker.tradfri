{
  "version": 3,
  "sources": ["../../src/lib/array-extensions.ts"],
  "sourcesContent": ["///\n/// Stellt Erweiterungsmethoden f\u00FCr Arrays bereit\n///\n\n/**\n * Gibt die Schnittmenge zweier numerischer Arrays aus,\n * es wird angenommen, dass sie schon sortiert sind\n * @param a\n * @param b\n */\nexport function intersect(a: number[], b: number[]): number[] {\n\tlet ai = 0;\n\tlet bi = 0;\n\tconst ret = [];\n\n\twhile (ai < a.length && bi < b.length) {\n\t\tif (a[ai] < b[bi]) ai++;\n\t\telse if (a[ai] > b[bi]) bi++;\n\t\telse {\n\t\t\tret.push(a[ai]);\n\t\t\tai++;\n\t\t\tbi++;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n/// gibt die Elemente zur\u00FCck, die in a, aber nicht in b sind.\nexport function except<T>(a: T[], b: T[]): T[] {\n\treturn a.filter((el) => b.indexOf(el) === -1);\n}\n\n/// Erzeugt ein Range-Array\nexport function range(min: number, max: number): number[] {\n\t// Potentiell Reihenfolge tauschen\n\tif (min > max) [max, min] = [min, max];\n\n\tconst N = max - min + 1;\n\treturn Array.from(new Array(N), (_, index) => index + min);\n}\n\n// Gibt das erste Element eines Array zur\u00FCck, das mit dem angegebenen Filter \u00FCbereinstimmt\nexport function firstOrDefault<T>(\n\tarr: T[],\n\tfilter: (item: T) => boolean,\n): T | null {\n\tfor (const item of arr) {\n\t\tif (filter(item)) return item;\n\t}\n\treturn null;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUO,mBAAmB,GAAa,GAAuB;AAC7D,MAAI,KAAK;AACT,MAAI,KAAK;AACT,QAAM,MAAM;AAEZ,SAAO,KAAK,EAAE,UAAU,KAAK,EAAE,QAAQ;AACtC,QAAI,EAAE,MAAM,EAAE;AAAK;AAAA,aACV,EAAE,MAAM,EAAE;AAAK;AAAA,SACnB;AACJ,UAAI,KAAK,EAAE;AACX;AACA;AAAA;AAAA;AAIF,SAAO;AAAA;AAID,gBAAmB,GAAQ,GAAa;AAC9C,SAAO,EAAE,OAAO,CAAC,OAAO,EAAE,QAAQ,QAAQ;AAAA;AAIpC,eAAe,KAAa,KAAuB;AAEzD,MAAI,MAAM;AAAK,KAAC,KAAK,OAAO,CAAC,KAAK;AAElC,QAAM,IAAI,MAAM,MAAM;AACtB,SAAO,MAAM,KAAK,IAAI,MAAM,IAAI,CAAC,GAAG,UAAU,QAAQ;AAAA;AAIhD,wBACN,KACA,QACW;AACX,aAAW,QAAQ,KAAK;AACvB,QAAI,OAAO;AAAO,aAAO;AAAA;AAE1B,SAAO;AAAA;",
  "names": []
}
