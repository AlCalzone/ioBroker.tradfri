{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["// Adapter-Utils laden\nimport * as utils from \"@iobroker/adapter-core\";\nimport { assertNever } from \"alcalzone-shared/helpers\";\n// Eigene Module laden\nimport { composeObject, entries, values } from \"alcalzone-shared/objects\";\n// actually load them now\nimport {\n\tAccessory,\n\tAccessoryTypes,\n\tAirPurifier,\n\tAirPurifierOperation,\n\tBlind,\n\tBlindOperation,\n\tdiscoverGateway,\n\tGroup,\n\tLight,\n\tLightOperation,\n\tPlug,\n\tPlugOperation,\n\tScene,\n\tTradfriClient,\n\tTradfriError,\n\tTradfriErrorCodes,\n} from \"node-tradfri-client\";\nimport * as path from \"path\";\n// Adapter-Module laden\nimport { normalizeHexColor } from \"./lib/colors\";\nimport { ensureInstanceObjects, fixAdapterObjects } from \"./lib/fix-objects\";\nimport { ExtendedAdapter, Global as _ } from \"./lib/global\";\nimport {\n\tcalcGroupId,\n\tcalcGroupName,\n\tcalcObjId,\n\tcalcObjName,\n\textendDevice,\n\tgetInstanceId,\n\tgetRootId,\n\tupdatePossibleScenes,\n} from \"./lib/iobroker-objects\";\nimport { roundTo } from \"./lib/math\";\n// Datentypen laden\nimport { VirtualGroup } from \"./lib/virtual-group\";\nimport {\n\tapplyCustomObjectSubscriptions,\n\tapplyCustomStateSubscriptions,\n\tsubscribeStates,\n} from \"./modules/custom-subscriptions\";\nimport {\n\textendGroup,\n\tsyncGroupsWithState,\n\tupdateGroupStates,\n} from \"./modules/groups\";\nimport { onMessage } from \"./modules/message\";\nimport {\n\toperateVirtualGroup,\n\trenameDevice,\n\trenameGroup,\n\tstopBlinds,\n} from \"./modules/operations\";\nimport { session as $ } from \"./modules/session\";\n\nlet connectionAlive: boolean;\nlet adapter: ExtendedAdapter;\n\nfunction startAdapter(options: Partial<utils.AdapterOptions> = {}) {\n\treturn (adapter = utils.adapter({\n\t\t// Default options\n\t\t...options,\n\t\t// custom options\n\t\tname: \"tradfri\",\n\n\t\t// Wird aufgerufen, wenn Adapter initialisiert wird\n\t\tready: async () => {\n\t\t\t// Adapter-Instanz global machen\n\t\t\tadapter = _.extend(adapter);\n\t\t\t_.adapter = adapter;\n\n\t\t\t// Fix our adapter objects to repair incompatibilities between versions\n\t\t\tawait ensureInstanceObjects();\n\t\t\tawait fixAdapterObjects();\n\n\t\t\t// we're not connected yet!\n\t\t\tawait adapter.setStateAsync(\"info.connection\", false, true);\n\n\t\t\t// Sicherstellen, dass die Optionen vollst\u00E4ndig ausgef\u00FCllt sind.\n\t\t\tif (\n\t\t\t\tadapter.config &&\n\t\t\t\t((adapter.config.host != null && adapter.config.host !== \"\") ||\n\t\t\t\t\tadapter.config.discoverGateway) &&\n\t\t\t\t((adapter.config.securityCode != null &&\n\t\t\t\t\tadapter.config.securityCode !== \"\") ||\n\t\t\t\t\t(adapter.config.identity != null &&\n\t\t\t\t\t\tadapter.config.identity !== \"\"))\n\t\t\t) {\n\t\t\t\t// alles gut\n\t\t\t} else {\n\t\t\t\tadapter.log.error(\n\t\t\t\t\t\"Please set the connection params in the adapter options before starting the adapter!\",\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Auth-Parameter laden\n\t\t\tlet hostname =\n\t\t\t\tadapter.config.host && adapter.config.host.toLowerCase();\n\t\t\tconst useAutoDiscovery = adapter.config.discoverGateway;\n\t\t\tconst securityCode = adapter.config.securityCode;\n\t\t\tlet identity = adapter.config.identity;\n\t\t\tlet psk = adapter.config.psk;\n\n\t\t\tif (useAutoDiscovery) {\n\t\t\t\t_.log(\"Discovering the gateway automatically...\");\n\t\t\t\tconst discovered = await discoverGateway();\n\t\t\t\tif (discovered && discovered.addresses.length) {\n\t\t\t\t\t_.log(\n\t\t\t\t\t\t`Found gateway ${\n\t\t\t\t\t\t\tdiscovered.name || \"with unknown name\"\n\t\t\t\t\t\t} at ${discovered.addresses[0]}`,\n\t\t\t\t\t);\n\t\t\t\t\thostname = discovered.addresses[0];\n\t\t\t\t} else {\n\t\t\t\t\t_.log(\"discovery failed!\", \"warn\");\n\t\t\t\t\tif (!hostname) {\n\t\t\t\t\t\tadapter.log.error(\n\t\t\t\t\t\t\t\"In order to use this adapter without auto-discovery, please set a hostname!\",\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Sicherstellen, dass die Anzahl der Nachkommastellen eine Zahl ist\n\t\t\tif (typeof adapter.config.roundToDigits === \"string\") {\n\t\t\t\tawait updateConfig({\n\t\t\t\t\troundToDigits: parseInt(adapter.config.roundToDigits, 10),\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// redirect console output\n\t\t\t// console.log = (msg) => adapter.log.debug(\"STDOUT > \" + msg);\n\t\t\t// console.error = (msg) => adapter.log.error(\"STDERR > \" + msg);\n\n\t\t\t// watch own states\n\t\t\tadapter.subscribeStates(`${adapter.namespace}.*`);\n\t\t\tadapter.subscribeObjects(`${adapter.namespace}.*`);\n\t\t\t// add special watch for lightbulb and blind states, so we can later sync the group states\n\t\t\tsubscribeStates(/L\\-\\d+\\.lightbulb\\./, syncGroupsWithState);\n\t\t\tsubscribeStates(/B\\-\\d+\\.blind\\./, syncGroupsWithState);\n\n\t\t\t$.tradfri = new TradfriClient(hostname!, {\n\t\t\t\tcustomLogger: _.log,\n\t\t\t\twatchConnection: true,\n\t\t\t});\n\n\t\t\tif (identity && identity.length > 0 && psk && psk.length > 0) {\n\t\t\t\t// connect with previously negotiated identity and psk\n\t\t\t\t$.tradfri.on(\n\t\t\t\t\t\"connection failed\",\n\t\t\t\t\t(attempt: number, maxAttempts: number) => {\n\t\t\t\t\t\t_.log(\n\t\t\t\t\t\t\t`failed connection attempt ${attempt} of ${\n\t\t\t\t\t\t\t\tNumber.isFinite(maxAttempts) ? maxAttempts : \"\u221E\"\n\t\t\t\t\t\t\t}`,\n\t\t\t\t\t\t\t\"warn\",\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\ttry {\n\t\t\t\t\tawait $.tradfri.connect(identity!, psk!);\n\t\t\t\t} catch (e: any) {\n\t\t\t\t\tif (e instanceof TradfriError) {\n\t\t\t\t\t\tswitch (e.code) {\n\t\t\t\t\t\t\tcase TradfriErrorCodes.ConnectionTimedOut: {\n\t\t\t\t\t\t\t\t_.log(\n\t\t\t\t\t\t\t\t\t`The gateway ${hostname} is unreachable or did not respond in time!`,\n\t\t\t\t\t\t\t\t\t\"error\",\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t_.log(\n\t\t\t\t\t\t\t\t\t`Please check your network and adapter settings and restart the adapter!`,\n\t\t\t\t\t\t\t\t\t\"error\",\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase TradfriErrorCodes.AuthenticationFailed: {\n\t\t\t\t\t\t\t\t_.log(\n\t\t\t\t\t\t\t\t\t`The stored credentials are no longer valid!`,\n\t\t\t\t\t\t\t\t\t\"warn\",\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t_.log(\n\t\t\t\t\t\t\t\t\t`The adapter will now restart and re-authenticate! If not, please restart it manually.`,\n\t\t\t\t\t\t\t\t\t\"warn\",\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tawait updateConfig({\n\t\t\t\t\t\t\t\t\tidentity: \"\",\n\t\t\t\t\t\t\t\t\tpsk: \"\",\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase TradfriErrorCodes.ConnectionFailed: {\n\t\t\t\t\t\t\t\t_.log(\n\t\t\t\t\t\t\t\t\t`Could not connect to the gateway ${hostname}!`,\n\t\t\t\t\t\t\t\t\t\"error\",\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t_.log(e.message, \"error\");\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_.log(\n\t\t\t\t\t\t\t`Could not connect to the gateway ${hostname}!`,\n\t\t\t\t\t\t\t\"error\",\n\t\t\t\t\t\t);\n\t\t\t\t\t\t_.log(e.message, \"error\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (securityCode != null && securityCode.length > 0) {\n\t\t\t\t// use the security code to create an identity and psk\n\t\t\t\ttry {\n\t\t\t\t\t({ identity, psk } = await $.tradfri.authenticate(\n\t\t\t\t\t\tsecurityCode,\n\t\t\t\t\t));\n\t\t\t\t\t// store it and restart the adapter\n\t\t\t\t\t_.log(\n\t\t\t\t\t\t`The authentication was successful. The adapter should now restart. If not, please restart it manually.`,\n\t\t\t\t\t\t\"info\",\n\t\t\t\t\t);\n\t\t\t\t\tawait updateConfig({\n\t\t\t\t\t\tidentity,\n\t\t\t\t\t\tpsk,\n\t\t\t\t\t});\n\t\t\t\t} catch (e: any) {\n\t\t\t\t\tif (e instanceof TradfriError) {\n\t\t\t\t\t\tswitch (e.code) {\n\t\t\t\t\t\t\tcase TradfriErrorCodes.ConnectionTimedOut: {\n\t\t\t\t\t\t\t\t_.log(\n\t\t\t\t\t\t\t\t\t`The gateway ${hostname} is unreachable or did not respond in time!`,\n\t\t\t\t\t\t\t\t\t\"error\",\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t_.log(\n\t\t\t\t\t\t\t\t\t`Please check your network and adapter settings and restart the adapter!`,\n\t\t\t\t\t\t\t\t\t\"error\",\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase TradfriErrorCodes.AuthenticationFailed: {\n\t\t\t\t\t\t\t\t_.log(\n\t\t\t\t\t\t\t\t\t`The security code is incorrect or something else went wrong with the authentication.`,\n\t\t\t\t\t\t\t\t\t\"error\",\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t_.log(\n\t\t\t\t\t\t\t\t\t`Please check your adapter settings and restart the adapter!`,\n\t\t\t\t\t\t\t\t\t\"error\",\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase TradfriErrorCodes.ConnectionFailed: {\n\t\t\t\t\t\t\t\t_.log(\n\t\t\t\t\t\t\t\t\t`Could not authenticate with the gateway ${hostname}!`,\n\t\t\t\t\t\t\t\t\t\"error\",\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t_.log(e.message, \"error\");\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_.log(\n\t\t\t\t\t\t\t`Could not authenticate with the gateway ${hostname}!`,\n\t\t\t\t\t\t\t\"error\",\n\t\t\t\t\t\t);\n\t\t\t\t\t\t_.log(e.message, \"error\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// watch the connection\n\t\t\tawait adapter.setStateAsync(\"info.connection\", true, true);\n\t\t\tconnectionAlive = true;\n\t\t\t$.tradfri\n\t\t\t\t.on(\"connection alive\", () => {\n\t\t\t\t\tif (connectionAlive) return;\n\t\t\t\t\t_.log(\"Connection to gateway reestablished\", \"info\");\n\t\t\t\t\tadapter.setState(\"info.connection\", true, true);\n\t\t\t\t\tconnectionAlive = true;\n\t\t\t\t})\n\t\t\t\t.on(\"connection lost\", () => {\n\t\t\t\t\tif (!connectionAlive) return;\n\t\t\t\t\t_.log(\"Lost connection to gateway\", \"warn\");\n\t\t\t\t\tadapter.setState(\"info.connection\", false, true);\n\t\t\t\t\tconnectionAlive = false;\n\t\t\t\t});\n\n\t\t\tawait loadDevices();\n\t\t\tawait loadGroups();\n\t\t\tawait loadVirtualGroups();\n\n\t\t\t$.tradfri\n\t\t\t\t.on(\"device updated\", tradfri_deviceUpdated)\n\t\t\t\t.on(\"device removed\", tradfri_deviceRemoved)\n\t\t\t\t.on(\"group updated\", tradfri_groupUpdated)\n\t\t\t\t.on(\"group removed\", tradfri_groupRemoved)\n\t\t\t\t.on(\"scene updated\", tradfri_sceneUpdated)\n\t\t\t\t.on(\"scene removed\", tradfri_sceneRemoved)\n\t\t\t\t.on(\"error\", tradfri_error);\n\t\t\tobserveAll();\n\t\t},\n\n\t\t// Handle sendTo-Messages\n\t\tmessage: onMessage,\n\n\t\tobjectChange: (id, obj) => {\n\t\t\t_.log(\n\t\t\t\t`{{blue}} object with id ${id} ${obj ? \"updated\" : \"deleted\"}`,\n\t\t\t\t\"debug\",\n\t\t\t);\n\n\t\t\tif (id.startsWith(adapter.namespace)) {\n\t\t\t\t// this is our own object.\n\n\t\t\t\tif (obj) {\n\t\t\t\t\t// first check if we have to modify a device/group/whatever\n\t\t\t\t\tconst instanceId = getInstanceId(id);\n\t\t\t\t\tif (instanceId == undefined) return;\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tobj.type === \"device\" &&\n\t\t\t\t\t\tinstanceId in $.devices &&\n\t\t\t\t\t\t$.devices[instanceId] != null\n\t\t\t\t\t) {\n\t\t\t\t\t\t// if this device is in the device list, check for changed properties\n\t\t\t\t\t\tconst acc = $.devices[instanceId];\n\t\t\t\t\t\tif (obj.common && obj.common.name !== acc.name) {\n\t\t\t\t\t\t\t// the name has changed, notify the gateway\n\t\t\t\t\t\t\t_.log(\n\t\t\t\t\t\t\t\t`the device ${id} was renamed to \"${\n\t\t\t\t\t\t\t\t\tobj.common.name as string\n\t\t\t\t\t\t\t\t}\"`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\trenameDevice(acc, obj.common.name as string);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tobj.type === \"channel\" &&\n\t\t\t\t\t\tinstanceId in $.groups &&\n\t\t\t\t\t\t$.groups[instanceId] != null\n\t\t\t\t\t) {\n\t\t\t\t\t\t// if this group is in the groups list, check for changed properties\n\t\t\t\t\t\tconst grp = $.groups[instanceId].group;\n\t\t\t\t\t\tif (obj.common && obj.common.name !== grp.name) {\n\t\t\t\t\t\t\t// the name has changed, notify the gateway\n\t\t\t\t\t\t\t_.log(\n\t\t\t\t\t\t\t\t`the group ${id} was renamed to \"${\n\t\t\t\t\t\t\t\t\tobj.common.name as string\n\t\t\t\t\t\t\t\t}\"`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\trenameGroup(grp, obj.common.name as string);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// remember the object\n\t\t\t\t\t$.objects[id] = obj;\n\t\t\t\t} else {\n\t\t\t\t\t// object deleted, forget it\n\t\t\t\t\tif (id in $.objects) delete $.objects[id];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// apply additional subscriptions we've defined\n\t\t\tapplyCustomObjectSubscriptions(id, obj);\n\t\t},\n\n\t\tstateChange: async (id, state) => {\n\t\t\tif (state) {\n\t\t\t\t_.log(\n\t\t\t\t\t`{{blue}} state with id ${id} updated: ack=${\n\t\t\t\t\t\tstate.ack\n\t\t\t\t\t}; val=${String(state.val)}`,\n\t\t\t\t\t\"debug\",\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t_.log(`{{blue}} state with id ${id} deleted`, \"debug\");\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t!connectionAlive &&\n\t\t\t\tstate &&\n\t\t\t\t!state.ack &&\n\t\t\t\tid.startsWith(adapter.namespace)\n\t\t\t) {\n\t\t\t\t_.log(\n\t\t\t\t\t\"Not connected to the gateway. Cannot send changes!\",\n\t\t\t\t\t\"warn\",\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// apply additional subscriptions we've defined\n\t\t\tapplyCustomStateSubscriptions(id, state);\n\n\t\t\t// Eigene Handling-Logik zum Schluss, damit wir return benutzen k\u00F6nnen\n\t\t\tif (state && !state.ack && id.startsWith(adapter.namespace)) {\n\t\t\t\t// our own state was changed from within ioBroker, react to it\n\n\t\t\t\tconst stateObj = $.objects[id];\n\t\t\t\tif (\n\t\t\t\t\t!(\n\t\t\t\t\t\tstateObj &&\n\t\t\t\t\t\tstateObj.type === \"state\" &&\n\t\t\t\t\t\tstateObj.native &&\n\t\t\t\t\t\tstateObj.native.path\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\treturn;\n\n\t\t\t\t// get \"official\" value for the parent object\n\t\t\t\tconst rootId = getRootId(id);\n\t\t\t\tif (rootId) {\n\t\t\t\t\t// get the ioBroker object\n\t\t\t\t\tconst rootObj = $.objects[rootId];\n\n\t\t\t\t\t// for now: handle changes on a case by case basis\n\t\t\t\t\t// everything else is too complicated for now\n\t\t\t\t\tlet val: ioBroker.State[\"val\"] | undefined = state.val;\n\t\t\t\t\tif (stateObj.common.type === \"number\") {\n\t\t\t\t\t\t// node-tradfri-client handles floating point numbers,\n\t\t\t\t\t\t// but we'll round to 2 digits for clarity (or the configured value)\n\t\t\t\t\t\tlet roundToDigits = adapter.config.roundToDigits || 2;\n\t\t\t\t\t\t// don't round the transition duration!\n\t\t\t\t\t\tif (id.endsWith(\"transitionDuration\"))\n\t\t\t\t\t\t\troundToDigits = 2;\n\t\t\t\t\t\tval = roundTo(val as unknown as number, roundToDigits);\n\t\t\t\t\t\tif (stateObj.common.min != null)\n\t\t\t\t\t\t\tval = Math.max(stateObj.common.min, val);\n\t\t\t\t\t\tif (stateObj.common.max != null)\n\t\t\t\t\t\t\tval = Math.min(stateObj.common.max, val);\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch (rootObj.native.type) {\n\t\t\t\t\t\tcase \"group\": {\n\t\t\t\t\t\t\t// read the instanceId and get a reference value\n\t\t\t\t\t\t\tif (!(rootObj.native.instanceId in $.groups)) {\n\t\t\t\t\t\t\t\t_.log(\n\t\t\t\t\t\t\t\t\t`The group with ID ${rootObj.native.instanceId} was not found!`,\n\t\t\t\t\t\t\t\t\t\"warn\",\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst group =\n\t\t\t\t\t\t\t\t$.groups[rootObj.native.instanceId].group;\n\t\t\t\t\t\t\t// if the change was acknowledged, update the state later\n\t\t\t\t\t\t\tlet wasAcked = false;\n\n\t\t\t\t\t\t\tif (id.endsWith(\".state\")) {\n\t\t\t\t\t\t\t\twasAcked = !(await group.toggle(\n\t\t\t\t\t\t\t\t\tval as unknown as boolean,\n\t\t\t\t\t\t\t\t));\n\t\t\t\t\t\t\t} else if (id.endsWith(\".brightness\")) {\n\t\t\t\t\t\t\t\twasAcked = !(await group.setBrightness(\n\t\t\t\t\t\t\t\t\tval as unknown as number,\n\t\t\t\t\t\t\t\t\tawait getTransitionDuration(group),\n\t\t\t\t\t\t\t\t));\n\t\t\t\t\t\t\t} else if (id.endsWith(\".position\")) {\n\t\t\t\t\t\t\t\twasAcked = !(await group.setPosition(\n\t\t\t\t\t\t\t\t\tval as unknown as number,\n\t\t\t\t\t\t\t\t));\n\t\t\t\t\t\t\t} else if (id.endsWith(\".activeScene\")) {\n\t\t\t\t\t\t\t\t// turn on and activate a scene\n\t\t\t\t\t\t\t\twasAcked = !(await group.activateScene(\n\t\t\t\t\t\t\t\t\tval as unknown as number,\n\t\t\t\t\t\t\t\t));\n\t\t\t\t\t\t\t} else if (id.endsWith(\".color\")) {\n\t\t\t\t\t\t\t\t// color change is only supported manually, so we operate\n\t\t\t\t\t\t\t\t// the virtual state of this group\n\t\t\t\t\t\t\t\tval = normalizeHexColor(\n\t\t\t\t\t\t\t\t\tval as unknown as string,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (val != null) {\n\t\t\t\t\t\t\t\t\tstate.val = val;\n\t\t\t\t\t\t\t\t\tawait operateVirtualGroup(group, {\n\t\t\t\t\t\t\t\t\t\tcolor: val,\n\t\t\t\t\t\t\t\t\t\ttransitionTime:\n\t\t\t\t\t\t\t\t\t\t\tawait getTransitionDuration(group),\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\twasAcked = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (id.endsWith(\".colorTemperature\")) {\n\t\t\t\t\t\t\t\t// color change is only supported manually, so we operate\n\t\t\t\t\t\t\t\t// the virtual state of this group\n\t\t\t\t\t\t\t\tawait operateVirtualGroup(group, {\n\t\t\t\t\t\t\t\t\tcolorTemperature: val as unknown as number,\n\t\t\t\t\t\t\t\t\ttransitionTime: await getTransitionDuration(\n\t\t\t\t\t\t\t\t\t\tgroup,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\twasAcked = true;\n\t\t\t\t\t\t\t} else if (/\\.(hue|saturation)$/.test(id)) {\n\t\t\t\t\t\t\t\t// hue and saturation have to be set together\n\t\t\t\t\t\t\t\tconst prefix = id.substr(\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\tid.lastIndexOf(\".\") + 1,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t// Try to read the hue and saturation states. If one of them doesn't exist,\n\t\t\t\t\t\t\t\t// we cannot issue a command\n\t\t\t\t\t\t\t\tconst hueState = await _.adapter.getStateAsync(\n\t\t\t\t\t\t\t\t\tprefix + \"hue\",\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (hueState == undefined) return;\n\t\t\t\t\t\t\t\tconst saturationState =\n\t\t\t\t\t\t\t\t\tawait _.adapter.getStateAsync(\n\t\t\t\t\t\t\t\t\t\tprefix + \"saturation\",\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (saturationState == undefined) return;\n\n\t\t\t\t\t\t\t\tconst hue = hueState.val as unknown as number;\n\t\t\t\t\t\t\t\tconst saturation =\n\t\t\t\t\t\t\t\t\tsaturationState.val as unknown as number;\n\t\t\t\t\t\t\t\t// color change is only supported manually, so we operate\n\t\t\t\t\t\t\t\t// the virtual state of this group\n\t\t\t\t\t\t\t\tawait operateVirtualGroup(group, {\n\t\t\t\t\t\t\t\t\thue,\n\t\t\t\t\t\t\t\t\tsaturation,\n\t\t\t\t\t\t\t\t\ttransitionTime: await getTransitionDuration(\n\t\t\t\t\t\t\t\t\t\tgroup,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\twasAcked = true;\n\t\t\t\t\t\t\t} else if (id.endsWith(\".transitionDuration\")) {\n\t\t\t\t\t\t\t\t// this is part of another operation, just ack the state\n\t\t\t\t\t\t\t\twasAcked = true;\n\t\t\t\t\t\t\t} else if (id.endsWith(\".stopBlinds\")) {\n\t\t\t\t\t\t\t\t// This is a button without feedback, so no need to setState afterwards\n\t\t\t\t\t\t\t\tawait group.stopBlinds();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// ack the state if neccessary and return\n\t\t\t\t\t\t\tif (wasAcked)\n\t\t\t\t\t\t\t\tadapter.setStateAsync(id, state, true);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase \"virtual group\": {\n\t\t\t\t\t\t\t// find the virtual group instance\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!(rootObj.native.instanceId in $.virtualGroups)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t_.log(\n\t\t\t\t\t\t\t\t\t`The virtual group with ID ${rootObj.native.instanceId} was not found!`,\n\t\t\t\t\t\t\t\t\t\"warn\",\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst vGroup =\n\t\t\t\t\t\t\t\t$.virtualGroups[rootObj.native.instanceId];\n\n\t\t\t\t\t\t\tlet operation:\n\t\t\t\t\t\t\t\t| LightOperation\n\t\t\t\t\t\t\t\t| BlindOperation\n\t\t\t\t\t\t\t\t| PlugOperation\n\t\t\t\t\t\t\t\t| AirPurifierOperation\n\t\t\t\t\t\t\t\t| undefined;\n\t\t\t\t\t\t\tlet wasAcked = false;\n\n\t\t\t\t\t\t\tif (id.endsWith(\".state\")) {\n\t\t\t\t\t\t\t\toperation = {\n\t\t\t\t\t\t\t\t\tonOff: val as unknown as boolean,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t} else if (id.endsWith(\".brightness\")) {\n\t\t\t\t\t\t\t\toperation = {\n\t\t\t\t\t\t\t\t\tdimmer: val as unknown as number,\n\t\t\t\t\t\t\t\t\ttransitionTime: await getTransitionDuration(\n\t\t\t\t\t\t\t\t\t\tvGroup,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t} else if (id.endsWith(\".position\")) {\n\t\t\t\t\t\t\t\toperation = {\n\t\t\t\t\t\t\t\t\tposition: val as unknown as number,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t} else if (id.endsWith(\".color\")) {\n\t\t\t\t\t\t\t\tval = normalizeHexColor(\n\t\t\t\t\t\t\t\t\tval as unknown as string,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (val != null) {\n\t\t\t\t\t\t\t\t\tstate.val = val;\n\t\t\t\t\t\t\t\t\toperation = {\n\t\t\t\t\t\t\t\t\t\tcolor: val,\n\t\t\t\t\t\t\t\t\t\ttransitionTime:\n\t\t\t\t\t\t\t\t\t\t\tawait getTransitionDuration(vGroup),\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (id.endsWith(\".colorTemperature\")) {\n\t\t\t\t\t\t\t\toperation = {\n\t\t\t\t\t\t\t\t\tcolorTemperature: val as unknown as number,\n\t\t\t\t\t\t\t\t\ttransitionTime: await getTransitionDuration(\n\t\t\t\t\t\t\t\t\t\tvGroup,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t} else if (/\\.(hue|saturation)$/.test(id)) {\n\t\t\t\t\t\t\t\t// hue and saturation have to be set together\n\t\t\t\t\t\t\t\tconst prefix = id.substr(\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\tid.lastIndexOf(\".\") + 1,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t// Try to read the hue and saturation states. If one of them doesn't exist,\n\t\t\t\t\t\t\t\t// we cannot issue a command\n\t\t\t\t\t\t\t\tconst hueState = await _.adapter.getStateAsync(\n\t\t\t\t\t\t\t\t\tprefix + \"hue\",\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (hueState == undefined) return;\n\t\t\t\t\t\t\t\tconst saturationState =\n\t\t\t\t\t\t\t\t\tawait _.adapter.getStateAsync(\n\t\t\t\t\t\t\t\t\t\tprefix + \"saturation\",\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (saturationState == undefined) return;\n\n\t\t\t\t\t\t\t\tconst hue = hueState.val as unknown as number;\n\t\t\t\t\t\t\t\tconst saturation =\n\t\t\t\t\t\t\t\t\tsaturationState.val as unknown as number;\n\n\t\t\t\t\t\t\t\toperation = {\n\t\t\t\t\t\t\t\t\thue,\n\t\t\t\t\t\t\t\t\tsaturation,\n\t\t\t\t\t\t\t\t\ttransitionTime: await getTransitionDuration(\n\t\t\t\t\t\t\t\t\t\tvGroup,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t} else if (id.endsWith(\".transitionDuration\")) {\n\t\t\t\t\t\t\t\t// No operation here, since this is part of another one\n\t\t\t\t\t\t\t\twasAcked = true;\n\t\t\t\t\t\t\t} else if (id.endsWith(\".stopBlinds\")) {\n\t\t\t\t\t\t\t\t// This is a button without feedback, so no need to setState afterwards\n\t\t\t\t\t\t\t\tawait stopBlinds(vGroup);\n\t\t\t\t\t\t\t} else if (id.endsWith(\".whenPowerRestored\")) {\n\t\t\t\t\t\t\t\toperation = {\n\t\t\t\t\t\t\t\t\twhenPowerRestored: val as unknown as number,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t} else if (id.endsWith(\".fanMode\")) {\n\t\t\t\t\t\t\t\toperation = {\n\t\t\t\t\t\t\t\t\tfanMode: val as unknown as number,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t} else if (id.endsWith(\".fanSpeed\")) {\n\t\t\t\t\t\t\t\toperation = {\n\t\t\t\t\t\t\t\t\tfanSpeed: val as unknown as number,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t} else if (id.endsWith(\".statusLEDs\")) {\n\t\t\t\t\t\t\t\toperation = {\n\t\t\t\t\t\t\t\t\tstatusLEDs: val as unknown as boolean,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t} else if (id.endsWith(\".controlsLocked\")) {\n\t\t\t\t\t\t\t\toperation = {\n\t\t\t\t\t\t\t\t\tcontrolsLocked: val as unknown as boolean,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// update all lightbulbs in this group\n\t\t\t\t\t\t\tif (operation != null) {\n\t\t\t\t\t\t\t\toperateVirtualGroup(vGroup, operation);\n\t\t\t\t\t\t\t\twasAcked = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// and ack the state change\n\t\t\t\t\t\t\tif (wasAcked)\n\t\t\t\t\t\t\t\tadapter.setStateAsync(id, state, true);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t// accessory\n\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tid.indexOf(\".lightbulb.\") > -1 ||\n\t\t\t\t\t\t\t\tid.indexOf(\".plug.\") > -1 ||\n\t\t\t\t\t\t\t\tid.indexOf(\".blind.\") > -1 ||\n\t\t\t\t\t\t\t\tid.indexOf(\".airPurifier.\") > -1\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t// read the instanceId and get a reference value\n\t\t\t\t\t\t\t\tif (!(rootObj.native.instanceId in $.devices)) {\n\t\t\t\t\t\t\t\t\t_.log(\n\t\t\t\t\t\t\t\t\t\t`The device with ID ${rootObj.native.instanceId} was not found!`,\n\t\t\t\t\t\t\t\t\t\t\"warn\",\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst accessory =\n\t\t\t\t\t\t\t\t\t$.devices[rootObj.native.instanceId];\n\t\t\t\t\t\t\t\tconst light: Light | undefined =\n\t\t\t\t\t\t\t\t\taccessory.lightList &&\n\t\t\t\t\t\t\t\t\taccessory.lightList[0];\n\t\t\t\t\t\t\t\tconst plug: Plug | undefined =\n\t\t\t\t\t\t\t\t\taccessory.plugList && accessory.plugList[0];\n\t\t\t\t\t\t\t\tconst blind: Blind | undefined =\n\t\t\t\t\t\t\t\t\taccessory.blindList &&\n\t\t\t\t\t\t\t\t\taccessory.blindList[0];\n\t\t\t\t\t\t\t\tconst airPurifier: AirPurifier | undefined =\n\t\t\t\t\t\t\t\t\taccessory.airPurifierList &&\n\t\t\t\t\t\t\t\t\taccessory.airPurifierList[0];\n\t\t\t\t\t\t\t\tconst specificAccessory =\n\t\t\t\t\t\t\t\t\tlight || plug || blind || airPurifier;\n\t\t\t\t\t\t\t\tif (specificAccessory == undefined) {\n\t\t\t\t\t\t\t\t\t_.log(\n\t\t\t\t\t\t\t\t\t\t`Cannot operate an accessory that is neither a lightbulb nor a plug nor a blind nor an airPurifier!`,\n\t\t\t\t\t\t\t\t\t\t\"warn\",\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// if the change was acknowledged, update the state later\n\t\t\t\t\t\t\t\tlet wasAcked = false;\n\n\t\t\t\t\t\t\t\t// operate the lights depending on the set state\n\t\t\t\t\t\t\t\t// if no request was sent, we can ack the state immediately\n\t\t\t\t\t\t\t\tif (id.endsWith(\".state\")) {\n\t\t\t\t\t\t\t\t\twasAcked = !(await specificAccessory.toggle(\n\t\t\t\t\t\t\t\t\t\tval as unknown as boolean,\n\t\t\t\t\t\t\t\t\t));\n\t\t\t\t\t\t\t\t} else if (id.endsWith(\".brightness\")) {\n\t\t\t\t\t\t\t\t\tif (light != undefined) {\n\t\t\t\t\t\t\t\t\t\twasAcked = !(await light.setBrightness(\n\t\t\t\t\t\t\t\t\t\t\tval as unknown as number,\n\t\t\t\t\t\t\t\t\t\t\tawait getTransitionDuration(\n\t\t\t\t\t\t\t\t\t\t\t\taccessory,\n\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t));\n\t\t\t\t\t\t\t\t\t} else if (plug != undefined) {\n\t\t\t\t\t\t\t\t\t\twasAcked = !(await plug.setBrightness(\n\t\t\t\t\t\t\t\t\t\t\tval as unknown as number,\n\t\t\t\t\t\t\t\t\t\t));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (id.endsWith(\".position\")) {\n\t\t\t\t\t\t\t\t\tif (blind != undefined) {\n\t\t\t\t\t\t\t\t\t\twasAcked = !(await blind.setPosition(\n\t\t\t\t\t\t\t\t\t\t\tval as unknown as number,\n\t\t\t\t\t\t\t\t\t\t));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (id.endsWith(\".color\")) {\n\t\t\t\t\t\t\t\t\t// we need to differentiate here, because some ppl\n\t\t\t\t\t\t\t\t\t// might already have \"color\" states for white spectrum bulbs\n\t\t\t\t\t\t\t\t\t// in the future, we create different states for white and RGB bulbs\n\t\t\t\t\t\t\t\t\tif (light.spectrum === \"rgb\") {\n\t\t\t\t\t\t\t\t\t\tval = normalizeHexColor(\n\t\t\t\t\t\t\t\t\t\t\tval as unknown as string,\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tif (val != null) {\n\t\t\t\t\t\t\t\t\t\t\tstate.val = val;\n\t\t\t\t\t\t\t\t\t\t\twasAcked = !(await light.setColor(\n\t\t\t\t\t\t\t\t\t\t\t\tval,\n\t\t\t\t\t\t\t\t\t\t\t\tawait getTransitionDuration(\n\t\t\t\t\t\t\t\t\t\t\t\t\taccessory,\n\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (light.spectrum === \"white\") {\n\t\t\t\t\t\t\t\t\t\twasAcked =\n\t\t\t\t\t\t\t\t\t\t\t!(await light.setColorTemperature(\n\t\t\t\t\t\t\t\t\t\t\t\tval as unknown as number,\n\t\t\t\t\t\t\t\t\t\t\t\tawait getTransitionDuration(\n\t\t\t\t\t\t\t\t\t\t\t\t\taccessory,\n\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t\t));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (id.endsWith(\".colorTemperature\")) {\n\t\t\t\t\t\t\t\t\twasAcked =\n\t\t\t\t\t\t\t\t\t\t!(await light.setColorTemperature(\n\t\t\t\t\t\t\t\t\t\t\tval as unknown as number,\n\t\t\t\t\t\t\t\t\t\t\tawait getTransitionDuration(\n\t\t\t\t\t\t\t\t\t\t\t\taccessory,\n\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t));\n\t\t\t\t\t\t\t\t} else if (/\\.(hue|saturation)$/.test(id)) {\n\t\t\t\t\t\t\t\t\t// hue and saturation have to be set together\n\t\t\t\t\t\t\t\t\tconst prefix = id.substr(\n\t\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\t\tid.lastIndexOf(\".\") + 1,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t// Try to read the hue and saturation states. If one of them doesn't exist,\n\t\t\t\t\t\t\t\t\t// we cannot issue a command\n\t\t\t\t\t\t\t\t\tconst hueState =\n\t\t\t\t\t\t\t\t\t\tawait _.adapter.getStateAsync(\n\t\t\t\t\t\t\t\t\t\t\tprefix + \"hue\",\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tif (hueState == undefined) return;\n\t\t\t\t\t\t\t\t\tconst saturationState =\n\t\t\t\t\t\t\t\t\t\tawait _.adapter.getStateAsync(\n\t\t\t\t\t\t\t\t\t\t\tprefix + \"saturation\",\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tif (saturationState == undefined) return;\n\n\t\t\t\t\t\t\t\t\tconst hue =\n\t\t\t\t\t\t\t\t\t\thueState.val as unknown as number;\n\t\t\t\t\t\t\t\t\tconst saturation =\n\t\t\t\t\t\t\t\t\t\tsaturationState.val as unknown as number;\n\t\t\t\t\t\t\t\t\twasAcked = !(await $.tradfri.operateLight(\n\t\t\t\t\t\t\t\t\t\taccessory,\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\thue,\n\t\t\t\t\t\t\t\t\t\t\tsaturation,\n\t\t\t\t\t\t\t\t\t\t\ttransitionTime:\n\t\t\t\t\t\t\t\t\t\t\t\tawait getTransitionDuration(\n\t\t\t\t\t\t\t\t\t\t\t\t\taccessory,\n\t\t\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t));\n\t\t\t\t\t\t\t\t} else if (id.endsWith(\".transitionDuration\")) {\n\t\t\t\t\t\t\t\t\t// this is part of another operation, just ack the state\n\t\t\t\t\t\t\t\t\twasAcked = true;\n\t\t\t\t\t\t\t\t} else if (id.endsWith(\"blind.stop\")) {\n\t\t\t\t\t\t\t\t\t// This is a button without feedback, so no need to setState afterwards\n\t\t\t\t\t\t\t\t\tawait blind.stop();\n\t\t\t\t\t\t\t\t} else if (id.endsWith(\".whenPowerRestored\")) {\n\t\t\t\t\t\t\t\t\twasAcked = !(await $.tradfri.operateLight(\n\t\t\t\t\t\t\t\t\t\taccessory,\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\twhenPowerRestored:\n\t\t\t\t\t\t\t\t\t\t\t\tval as unknown as number,\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t));\n\t\t\t\t\t\t\t\t} else if (id.endsWith(\".fanMode\")) {\n\t\t\t\t\t\t\t\t\tif (airPurifier != undefined) {\n\t\t\t\t\t\t\t\t\t\twasAcked =\n\t\t\t\t\t\t\t\t\t\t\t!(await airPurifier.setFanMode(\n\t\t\t\t\t\t\t\t\t\t\t\tval as unknown as number,\n\t\t\t\t\t\t\t\t\t\t\t));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (id.endsWith(\".fanSpeed\")) {\n\t\t\t\t\t\t\t\t\tif (airPurifier != undefined) {\n\t\t\t\t\t\t\t\t\t\twasAcked =\n\t\t\t\t\t\t\t\t\t\t\t!(await airPurifier.setFanSpeed(\n\t\t\t\t\t\t\t\t\t\t\t\tval as unknown as number,\n\t\t\t\t\t\t\t\t\t\t\t));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (id.endsWith(\".statusLEDs\")) {\n\t\t\t\t\t\t\t\t\tif (airPurifier != undefined) {\n\t\t\t\t\t\t\t\t\t\twasAcked =\n\t\t\t\t\t\t\t\t\t\t\t!(await airPurifier.setStatusLEDs(\n\t\t\t\t\t\t\t\t\t\t\t\tval as unknown as boolean,\n\t\t\t\t\t\t\t\t\t\t\t));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (id.endsWith(\".controlsLocked\")) {\n\t\t\t\t\t\t\t\t\tif (airPurifier != undefined) {\n\t\t\t\t\t\t\t\t\t\twasAcked =\n\t\t\t\t\t\t\t\t\t\t\t!(await airPurifier.setControlsLocked(\n\t\t\t\t\t\t\t\t\t\t\t\tval as unknown as boolean,\n\t\t\t\t\t\t\t\t\t\t\t));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// ack the state if neccessary and return\n\t\t\t\t\t\t\t\tif (wasAcked)\n\t\t\t\t\t\t\t\t\tadapter.setStateAsync(id, state, true);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (!state) {\n\t\t\t\t// TODO: find out what to do when states are deleted\n\t\t\t}\n\t\t},\n\n\t\tunload: (callback) => {\n\t\t\t// is called when adapter shuts down - callback has to be called under any circumstances!\n\t\t\ttry {\n\t\t\t\t// close the gateway connection\n\t\t\t\t$.tradfri.destroy();\n\t\t\t\tadapter.setState(\"info.connection\", false, true);\n\n\t\t\t\tcallback();\n\t\t\t} catch (e) {\n\t\t\t\tcallback();\n\t\t\t}\n\t\t},\n\t}) as ExtendedAdapter);\n}\n\nasync function updateConfig(newConfig: Partial<ioBroker.AdapterConfig>) {\n\t// Create the config object\n\tconst config: ioBroker.AdapterConfig = {\n\t\t...adapter.config,\n\t\t...newConfig,\n\t};\n\t// Update the adapter object\n\tconst adapterObj = (await adapter.getForeignObjectAsync(\n\t\t`system.adapter.${adapter.namespace}`,\n\t))!;\n\tadapterObj.native = config as Record<string, any>;\n\tawait adapter.setForeignObjectAsync(\n\t\t`system.adapter.${adapter.namespace}`,\n\t\tadapterObj,\n\t);\n}\n\n// ==================================\n// manage devices\n\nasync function observeAll(): Promise<void> {\n\tawait $.tradfri.observeDevices();\n\t_.log(\"received all devices\");\n\tawait $.tradfri.observeGroupsAndScenes();\n\t_.log(\"received all groups and scenes\");\n}\n\nfunction tradfri_deviceUpdated(device: Accessory) {\n\t// remember it\n\t$.devices[device.instanceId] = device;\n\t// create ioBroker device\n\textendDevice(device);\n}\n\nasync function tradfri_deviceRemoved(instanceId: number) {\n\tif (instanceId in $.devices) {\n\t\t// delete ioBroker device\n\t\tconst deviceName = calcObjName($.devices[instanceId]);\n\t\tawait adapter.deleteDeviceAsync(deviceName);\n\t\tdelete $.devices[instanceId];\n\t}\n}\n\nasync function tradfri_groupUpdated(group: Group) {\n\t// remember the group\n\tif (!(group.instanceId in $.groups)) {\n\t\t// if there's none, create one\n\t\t$.groups[group.instanceId] = {\n\t\t\tgroup: null!, // we'll assign this directly after the if branch\n\t\t\tscenes: {},\n\t\t};\n\t}\n\t$.groups[group.instanceId].group = group;\n\t// create ioBroker device\n\textendGroup(group);\n\t// clean up any states that might be incorrectly defined\n\tupdateGroupStates(group);\n\t// read the transition duration, because the gateway won't report it\n\tgroup.transitionTime = await getTransitionDuration(group);\n}\n\nasync function tradfri_groupRemoved(instanceId: number) {\n\tif (instanceId in $.groups) {\n\t\t// delete ioBroker group\n\t\tconst groupName = calcGroupName($.groups[instanceId].group);\n\t\tawait adapter.deleteChannelAsync(groupName);\n\t\t// remove group from dictionary\n\t\tdelete $.groups[instanceId];\n\t}\n}\n\nfunction tradfri_sceneUpdated(groupId: number, scene: Scene) {\n\tif (groupId in $.groups) {\n\t\t// remember the scene object, so we can later use it as a reference for updates\n\t\t$.groups[groupId].scenes[scene.instanceId] = scene;\n\t\t// Update the scene dropdown for the group\n\t\tupdatePossibleScenes($.groups[groupId]);\n\t}\n}\n\nfunction tradfri_sceneRemoved(groupId: number, instanceId: number) {\n\tif (groupId in $.groups) {\n\t\tconst groupInfo = $.groups[groupId];\n\t\t// remove scene from dictionary\n\t\tif (instanceId in groupInfo.scenes) delete groupInfo.scenes[instanceId];\n\t}\n}\n\nfunction tradfri_error(error: Error) {\n\tif (error instanceof TradfriError) {\n\t\tif (\n\t\t\terror.code === TradfriErrorCodes.NetworkReset ||\n\t\t\terror.code === TradfriErrorCodes.ConnectionTimedOut\n\t\t) {\n\t\t\treturn;\n\t\t} // it's okay, just swallow the error\n\t}\n\t_.log(error.toString(), \"error\");\n}\n\n/**\n * Returns the configured transition duration for an accessory or a group\n */\nasync function getTransitionDuration(\n\taccessoryOrGroup: Accessory | Group | VirtualGroup,\n): Promise<number> {\n\tlet stateId: string;\n\tif (accessoryOrGroup instanceof Accessory) {\n\t\tswitch (accessoryOrGroup.type) {\n\t\t\tcase AccessoryTypes.lightbulb:\n\t\t\t\tstateId =\n\t\t\t\t\tcalcObjId(accessoryOrGroup) +\n\t\t\t\t\t\".lightbulb.transitionDuration\";\n\t\t\tdefault:\n\t\t\t\treturn 0; // other accessories have no transition duration\n\t\t}\n\t} else if (\n\t\taccessoryOrGroup instanceof Group ||\n\t\taccessoryOrGroup instanceof VirtualGroup\n\t) {\n\t\tstateId = calcGroupId(accessoryOrGroup) + \".transitionDuration\";\n\t} else return assertNever(accessoryOrGroup);\n\n\tconst ret = await adapter.getStateAsync(stateId);\n\tif (ret != null) return ret.val as unknown as number;\n\treturn 0.5; // default\n}\n\n/**\n * Loads defined virtual groups from the ioBroker objects DB\n */\nasync function loadVirtualGroups(): Promise<void> {\n\t// find all defined virtual groups\n\tconst iobObjects = await _.$$(`${adapter.namespace}.VG-*`, \"channel\");\n\tconst groupObjects: ioBroker.Object[] = values(iobObjects).filter((g) => {\n\t\treturn (\n\t\t\tg.native != null &&\n\t\t\tg.native.instanceId != null &&\n\t\t\tg.native.deviceIDs != null &&\n\t\t\tg.native.type === \"virtual group\"\n\t\t);\n\t});\n\t// load them into the virtualGroups dict\n\tObject.assign(\n\t\t$.virtualGroups,\n\t\tcomposeObject<VirtualGroup>(\n\t\t\tgroupObjects.map((g) => {\n\t\t\t\tconst id: number = g.native.instanceId;\n\t\t\t\tconst deviceIDs: number[] = g.native.deviceIDs.map(\n\t\t\t\t\t(d: string) => parseInt(d, 10),\n\t\t\t\t);\n\t\t\t\tconst ret = new VirtualGroup(id);\n\t\t\t\tret.deviceIDs = deviceIDs;\n\t\t\t\tret.name = g.common.name as string;\n\t\t\t\treturn [`${id}`, ret] as [string, VirtualGroup];\n\t\t\t}),\n\t\t),\n\t);\n\t// remember the actual objects\n\tfor (const obj of values($.virtualGroups)) {\n\t\tconst id = calcGroupId(obj);\n\t\t$.objects[id] = iobObjects[id];\n\t\t// also remember all states\n\t\tconst stateObjs = await _.$$(`${id}.*`, \"state\");\n\t\tfor (const [sid, sobj] of entries(stateObjs)) {\n\t\t\t$.objects[sid] = sobj;\n\t\t}\n\t}\n}\n\n/**\n * Loads defined devices from the ioBroker objects DB\n */\nasync function loadDevices(): Promise<void> {\n\t// find all defined devices\n\tconst iobObjects = await _.$$(`${adapter.namespace}.*`, \"device\");\n\tconst deviceObjects: ioBroker.Object[] = values(iobObjects).filter((d) => {\n\t\treturn d.native && d.native.instanceId != null;\n\t});\n\t// remember the actual objects\n\tfor (const obj of deviceObjects) {\n\t\t$.objects[obj._id] = obj;\n\t\t// also remember all states\n\t\tconst stateObjs = await _.$$(`${obj._id}.*`, \"state\");\n\t\tfor (const [sid, sobj] of entries(stateObjs)) {\n\t\t\t$.objects[sid] = sobj;\n\t\t}\n\t}\n}\n\n/**\n * Loads defined devices from the ioBroker objects DB\n */\nasync function loadGroups(): Promise<void> {\n\t// find all defined groups\n\tconst iobObjects = await _.$$(`${adapter.namespace}.G-*`, \"channel\");\n\tconst groupObjects: ioBroker.Object[] = values(iobObjects).filter((g) => {\n\t\treturn (\n\t\t\tg.native && g.native.instanceId != null && g.native.type === \"group\"\n\t\t);\n\t});\n\t// remember the actual objects\n\tfor (const obj of groupObjects) {\n\t\t$.objects[obj._id] = obj;\n\t\t// also remember all states\n\t\tconst stateObjs = await _.$$(`${obj._id}.*`, \"state\");\n\t\tfor (const [sid, sobj] of entries(stateObjs)) {\n\t\t\t$.objects[sid] = sobj;\n\t\t}\n\t}\n}\n\nfunction getMessage(err: Error | string): string {\n\t// Irgendwo gibt es wohl einen Fehler ohne Message\n\tif (err == null) return \"undefined\";\n\tif (typeof err === \"string\") return err;\n\tif (err.message != null) return err.message;\n\tif (err.name != null) return err.name;\n\treturn err.toString();\n}\n\nfunction onUnhandledRejection(err: unknown) {\n\tlet message = \"unhandled promise rejection:\" + getMessage(err as any);\n\tif (err instanceof Error && err.stack != null)\n\t\tmessage += \"\\n> stack: \" + err.stack;\n\t((adapter && adapter.log) || console).error(message);\n\tterminate(1, \"unhandled promise rejection\");\n}\n\nfunction onUnhandledError(err: Error) {\n\tlet message = \"unhandled exception:\" + getMessage(err);\n\tif (err.stack != null) message += \"\\n> stack: \" + err.stack;\n\t((adapter && adapter.log) || console).error(message);\n\tterminate(1, \"unhandled exception\");\n}\n\nfunction terminate(exitCode?: number, reason?: string) {\n\tif (adapter && typeof adapter.terminate === \"function\") {\n\t\tadapter.terminate(reason);\n\t} else {\n\t\tprocess.exit(exitCode);\n\t}\n}\n\n// Trace unhandled errors\nprocess.on(\"unhandledRejection\", onUnhandledRejection);\nprocess.on(\"uncaughtException\", onUnhandledError);\n\n// try loading tradfri module to catch potential errors\nlet tradfriClientLibLoaded = false;\ntry {\n\trequire(\"node-tradfri-client\");\n\ttradfriClientLibLoaded = true;\n} catch (e) {\n\tconsole.error(`The module \"node-aead-crypto\" was not installed correctly!`);\n\tconsole.error(\n\t\t`To try reinstalling it, goto \"${path.join(__dirname, \"..\")}\" and run`,\n\t);\n\tconsole.error(`npm install --production`);\n\tconsole.error(`If that fails due to missing access rights, run`);\n\tconsole.error(\n\t\t`${\n\t\t\tprocess.platform !== \"win32\" ? \"sudo -H \" : \"\"\n\t\t}npm install --production --unsafe-perm`,\n\t);\n\tconsole.error(`instead. Afterwards, restart this adapter.`);\n}\n\nif (module.parent) {\n\t// Export startAdapter in compact mode\n\tif (tradfriClientLibLoaded) {\n\t\tmodule.exports = startAdapter;\n\t}\n} else {\n\t// Otherwise start the adapter immediately\n\tif (tradfriClientLibLoaded) {\n\t\tstartAdapter();\n\t} else {\n\t\tterminate(11, \"Required library missing\"); // Do not restart!\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
