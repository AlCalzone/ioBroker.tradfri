{
  "version": 3,
  "sources": ["../../src/modules/groups.ts"],
  "sourcesContent": ["import { entries, filter, values } from \"alcalzone-shared/objects\";\nimport { Accessory, AccessoryTypes, Group } from \"node-tradfri-client\";\nimport { Global as _ } from \"../lib/global\";\nimport {\n\tcalcGroupId,\n\tgetInstanceId,\n\tgroupToCommon,\n\tgroupToNative,\n\tobjectDefinitions,\n} from \"../lib/iobroker-objects\";\nimport { roundTo } from \"../lib/math\";\nimport { dig } from \"../lib/object-polyfill\";\nimport { VirtualGroup } from \"../lib/virtual-group\";\nimport { session as $ } from \"./session\";\n\n/* creates or edits an existing <group>-object for a virtual group */\nexport function extendVirtualGroup(group: VirtualGroup): void {\n\tconst objId = calcGroupId(group);\n\n\tif (objId in $.objects) {\n\t\t// check if we need to edit the existing object\n\t\tconst grpObj = $.objects[objId];\n\t\tlet changed = false;\n\t\t// update common part if neccessary\n\t\tconst newCommon = groupToCommon(group);\n\t\tif (JSON.stringify(grpObj.common) !== JSON.stringify(newCommon)) {\n\t\t\t// merge the common objects\n\t\t\tObject.assign(grpObj.common, newCommon);\n\t\t\tchanged = true;\n\t\t}\n\t\tconst newNative = groupToNative(group);\n\t\t// update native part if neccessary\n\t\tif (JSON.stringify(grpObj.native) !== JSON.stringify(newNative)) {\n\t\t\t// merge the native objects\n\t\t\tObject.assign(grpObj.native, newNative);\n\t\t\tchanged = true;\n\t\t}\n\t\tif (changed) _.adapter.setObject(objId, grpObj);\n\n\t\t// TODO: Update group states where applicable. See extendGroup for the code\n\t} else {\n\t\t// create new object\n\t\tconst devObj: ioBroker.Object = {\n\t\t\t_id: objId,\n\t\t\ttype: \"channel\",\n\t\t\tcommon: groupToCommon(group),\n\t\t\tnative: groupToNative(group),\n\t\t};\n\t\t_.adapter.setObject(objId, devObj);\n\n\t\t// also create state objects, depending on the accessory type\n\t\t// prettier-ignore\n\t\tconst stateObjs: Record<string, ioBroker.Object> = {\n\t\t\tstate: objectDefinitions.onOff(objId, \"virtual group\"),\n\t\t\twhenPowerRestored: objectDefinitions.whenPowerRestored(objId, \"virtual group\"),\n\t\t\ttransitionDuration: objectDefinitions.transitionDuration(objId, \"virtual group\"),\n\t\t\tbrightness: objectDefinitions.brightness(objId, \"virtual group\"),\n\t\t\tcolorTemperature: objectDefinitions.colorTemperature(objId, \"virtual group\"),\n\t\t\tcolor: objectDefinitions.color(objId, \"virtual group\"),\n\t\t\thue: objectDefinitions.hue(objId, \"virtual group\"),\n\t\t\tsaturation: objectDefinitions.saturation(objId, \"virtual group\"),\n\t\t\tposition: objectDefinitions.position(objId, \"virtual group\"),\n\t\t\tstopBlinds: objectDefinitions.stopBlinds(objId, \"virtual group\"),\n\t\t\tfanMode: objectDefinitions.fanMode(objId, \"virtual group\"),\n\t\t\tfanSpeed: objectDefinitions.fanSpeed(objId, \"virtual group\"),\n\t\t\tstatusLEDs: objectDefinitions.statusLEDs(objId, \"virtual group\"),\n\t\t\tcontrolsLocked: objectDefinitions.controlsLocked(objId, \"virtual group\"),\n\t\t};\n\n\t\tconst createObjects = Object.keys(stateObjs).map((key) => {\n\t\t\tconst obj = stateObjs[key];\n\t\t\tlet initialValue = null;\n\t\t\tif (obj.native.path != null) {\n\t\t\t\t// Object could have a default value, find it\n\t\t\t\tinitialValue = dig<any>(group, obj.native.path);\n\t\t\t}\n\t\t\t// create object and return the promise, so we can wait\n\t\t\treturn _.adapter.createOwnStateExAsync(obj._id, obj, initialValue);\n\t\t});\n\t\tPromise.all(createObjects);\n\t}\n}\n\n/* creates or edits an existing <group>-object for a group */\nexport function extendGroup(group: Group): void {\n\tconst objId = calcGroupId(group);\n\n\tif (objId in $.objects) {\n\t\t// check if we need to edit the existing object\n\t\tconst grpObj = $.objects[objId];\n\t\tlet changed = false;\n\t\t// update common part if neccessary\n\t\tconst newCommon = groupToCommon(group);\n\t\tif (JSON.stringify(grpObj.common) !== JSON.stringify(newCommon)) {\n\t\t\t// merge the common objects\n\t\t\tObject.assign(grpObj.common, newCommon);\n\t\t\tchanged = true;\n\t\t}\n\t\tconst newNative = groupToNative(group);\n\t\t// update native part if neccessary\n\t\tif (JSON.stringify(grpObj.native) !== JSON.stringify(newNative)) {\n\t\t\t// merge the native objects\n\t\t\tObject.assign(grpObj.native, newNative);\n\t\t\tchanged = true;\n\t\t}\n\t\tif (changed) _.adapter.setObject(objId, grpObj);\n\n\t\t// ====\n\n\t\t// from here we can update the states\n\t\t// filter out the ones belonging to this device with a property path\n\t\tconst stateObjs = filter(\n\t\t\t$.objects,\n\t\t\t(obj) => obj._id.startsWith(objId) && obj.native && obj.native.path,\n\t\t);\n\t\t// for each property try to update the value\n\t\tfor (const [id, obj] of entries(stateObjs)) {\n\t\t\ttry {\n\t\t\t\t// Object could have a default value, find it\n\t\t\t\tlet newValue = dig(group, obj.native.path);\n\t\t\t\tif (typeof newValue === \"function\") continue;\n\t\t\t\tconst roundToDigits = _.adapter.config.roundToDigits;\n\t\t\t\tif (\n\t\t\t\t\ttypeof roundToDigits === \"number\" &&\n\t\t\t\t\ttypeof newValue === \"number\"\n\t\t\t\t) {\n\t\t\t\t\tnewValue = roundTo(newValue, roundToDigits);\n\t\t\t\t}\n\t\t\t\t_.adapter.setState(id, (newValue as any) ?? null, true);\n\t\t\t} catch (e) {\n\t\t\t\t/* skip this value */\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// create new object\n\t\tconst devObj: ioBroker.Object = {\n\t\t\t_id: objId,\n\t\t\ttype: \"channel\",\n\t\t\tcommon: groupToCommon(group),\n\t\t\tnative: groupToNative(group),\n\t\t};\n\t\t_.adapter.setObject(objId, devObj);\n\n\t\t// also create state objects, depending on the accessory type\n\t\t// prettier-ignore\n\t\tconst stateObjs: Record<string, ioBroker.Object> = {\n\t\t\tactiveScene: objectDefinitions.activeScene(objId, \"group\"),\n\t\t\tstate: objectDefinitions.onOff(objId, \"group\"),\n\t\t\ttransitionDuration: objectDefinitions.transitionDuration(objId, \"group\"),\n\t\t\tbrightness: objectDefinitions.brightness(objId, \"group\"),\n\t\t\tcolorTemperature: objectDefinitions.colorTemperature(objId, \"group\"),\n\t\t\tcolor: objectDefinitions.color(objId, \"group\"),\n\t\t\thue: objectDefinitions.hue(objId, \"group\"),\n\t\t\tsaturation: objectDefinitions.saturation(objId, \"group\"),\n\t\t\tposition: objectDefinitions.position(objId, \"group\"),\n\t\t\tstopBlinds: objectDefinitions.stopBlinds(objId, \"group\"),\n\t\t};\n\n\t\tconst createObjects = Object.keys(stateObjs).map((key) => {\n\t\t\tconst obj = stateObjs[key];\n\t\t\tlet initialValue = null;\n\t\t\tif (obj.native.path != null) {\n\t\t\t\t// Object could have a default value, find it\n\t\t\t\tinitialValue = dig<any>(group, obj.native.path);\n\t\t\t}\n\t\t\t// create object and return the promise, so we can wait\n\t\t\treturn _.adapter.createOwnStateExAsync(obj._id, obj, initialValue);\n\t\t});\n\t\tPromise.all(createObjects);\n\t}\n}\n\n/** Returns the only value in the given array if they are all the same, otherwise null */\nfunction getCommonValue<T>(arr: T[]): T | null {\n\tfor (let i = 1; i < arr.length; i++) {\n\t\tif (arr[i] !== arr[i - 1]) return null;\n\t}\n\treturn arr[0];\n}\n\nconst updateTimers: Record<string, NodeJS.Timer> = {};\nfunction debounce(id: string, action: () => void, timeout: number) {\n\t// clear existing timeouts\n\tif (id in updateTimers) clearTimeout(updateTimers[id]);\n\t// set a new debounce timer\n\tupdateTimers[id] = setTimeout(() => {\n\t\tdelete updateTimers[id];\n\t\taction();\n\t}, timeout);\n}\n\nasync function updateGroupState(\n\tid: string,\n\tvalue: string | number | boolean | ioBroker.State | null,\n): Promise<void> {\n\tconst curState = await _.adapter.getStateAsync(id);\n\tif (curState != null && value == null) {\n\t\tawait _.adapter.delStateAsync(id);\n\t} else if (curState !== value) {\n\t\tconst roundToDigits = _.adapter.config.roundToDigits;\n\t\tif (typeof roundToDigits === \"number\" && typeof value === \"number\") {\n\t\t\tvalue = roundTo(value, roundToDigits);\n\t\t}\n\t\tawait _.adapter.setStateAsync(id, (value as any) ?? null, true);\n\t}\n}\n\n/**\n * Updates all group states that are equal for all its devices\n * @param changedAccessory If defined, only update the groups this is a part of.\n * @param changedStateId If defined, only update the corresponding states in the group.\n */\nexport function updateMultipleGroupStates(\n\tchangedAccessory?: Accessory,\n\tchangedStateId?: string,\n): void {\n\tconst groupsToUpdate: (Group | VirtualGroup)[] = values($.groups)\n\t\t.map((g) => g.group as Group | VirtualGroup)\n\t\t.concat(values($.virtualGroups))\n\t\t.filter(\n\t\t\t(g) =>\n\t\t\t\tchangedAccessory == null ||\n\t\t\t\t(g.deviceIDs != undefined &&\n\t\t\t\t\tg.deviceIDs.indexOf(changedAccessory.instanceId) > -1),\n\t\t);\n\tfor (const group of groupsToUpdate) {\n\t\tupdateGroupStates(group, changedStateId);\n\t}\n}\n\nexport function updateGroupStates(\n\tgroup: Group | VirtualGroup,\n\tchangedStateId?: string,\n): void {\n\tif (group.deviceIDs == null) return;\n\tconst objId = calcGroupId(group);\n\n\tconst groupBulbs = group.deviceIDs\n\t\t.map((id) => $.devices[id])\n\t\t.filter((a) => a != null && a.type === AccessoryTypes.lightbulb)\n\t\t.map((a) => a.lightList[0]);\n\tconst groupBlinds = group.deviceIDs\n\t\t.map((id) => $.devices[id])\n\t\t.filter((a) => a != null && a.type === AccessoryTypes.blind)\n\t\t.map((a) => a.blindList[0]);\n\tconst groupPlugs = group.deviceIDs\n\t\t.map((id) => $.devices[id])\n\t\t.filter((a) => a != null && a.type === AccessoryTypes.plug)\n\t\t.map((a) => a.plugList[0]);\n\tconst groupAPs = group.deviceIDs\n\t\t.map((id) => $.devices[id])\n\t\t.filter((a) => a != null && a.type === AccessoryTypes.airPurifier)\n\t\t.map((a) => a.airPurifierList[0]);\n\n\t// Seperate the bulbs into no spectrum/white spectrum/rgb bulbs\n\tconst whiteSpectrumBulbs = groupBulbs.filter((b) => b.spectrum === \"white\");\n\tconst rgbBulbs = groupBulbs.filter((b) => b.spectrum === \"rgb\");\n\n\t// we're debouncing the state changes, so group or scene updates don't result in\n\t// deleting and recreating states\n\tconst debounceTimeout = 250;\n\n\t// Try to update the on/off state\n\tif (\n\t\tgroupBulbs.length > 0 &&\n\t\t(changedStateId == null || changedStateId.endsWith(\"lightbulb.state\"))\n\t) {\n\t\tconst commonState = getCommonValue(groupBulbs.map((b) => b.onOff));\n\t\t// TODO: Assigning null is not allowed as per the node-tradfri-client definitions but it works\n\t\tgroup.onOff = commonState!;\n\t\tconst stateId = `${objId}.state`;\n\t\tdebounce(\n\t\t\tstateId,\n\t\t\t() => updateGroupState(stateId, commonState),\n\t\t\tdebounceTimeout,\n\t\t);\n\t}\n\t// Try to update the power restored state\n\tif (\n\t\tgroup instanceof VirtualGroup &&\n\t\tgroupBulbs.length > 0 &&\n\t\t(changedStateId == null ||\n\t\t\tchangedStateId.endsWith(\"lightbulb.whenPowerRestored\"))\n\t) {\n\t\tconst commonState = getCommonValue(\n\t\t\tgroupBulbs.map((b) => b.whenPowerRestored),\n\t\t);\n\t\tgroup.whenPowerRestored = commonState!;\n\t\tconst stateId = `${objId}.whenPowerRestored`;\n\t\tdebounce(\n\t\t\tstateId,\n\t\t\t() => updateGroupState(stateId, commonState),\n\t\t\tdebounceTimeout,\n\t\t);\n\t}\n\t// Try to update the brightness state\n\tif (\n\t\tgroupBulbs.length > 0 &&\n\t\t(changedStateId == null ||\n\t\t\tchangedStateId.endsWith(\"lightbulb.brightness\"))\n\t) {\n\t\tconst commonState = getCommonValue(groupBulbs.map((b) => b.dimmer));\n\t\t// TODO: Assigning null is not allowed as per the node-tradfri-client definitions but it works\n\t\tgroup.dimmer = commonState!;\n\t\tconst stateId = `${objId}.brightness`;\n\t\tdebounce(\n\t\t\tstateId,\n\t\t\t() => updateGroupState(stateId, commonState),\n\t\t\tdebounceTimeout,\n\t\t);\n\t}\n\t// Try to update the colorTemperature state\n\tif (\n\t\twhiteSpectrumBulbs.length > 0 &&\n\t\t(changedStateId == null ||\n\t\t\tchangedStateId.endsWith(\"lightbulb.colorTemperature\"))\n\t) {\n\t\tconst commonState =\n\t\t\twhiteSpectrumBulbs.length > 0\n\t\t\t\t? getCommonValue(\n\t\t\t\t\t\twhiteSpectrumBulbs.map((b) => b.colorTemperature),\n\t\t\t\t  )\n\t\t\t\t: null;\n\t\tconst stateId = `${objId}.colorTemperature`;\n\t\tdebounce(\n\t\t\tstateId,\n\t\t\t() => updateGroupState(stateId, commonState),\n\t\t\tdebounceTimeout,\n\t\t);\n\t}\n\t// Try to update the color state\n\tif (\n\t\trgbBulbs.length > 0 &&\n\t\t(changedStateId == null || changedStateId.endsWith(\"lightbulb.color\"))\n\t) {\n\t\tconst commonState =\n\t\t\trgbBulbs.length > 0\n\t\t\t\t? getCommonValue(rgbBulbs.map((b) => b.color))\n\t\t\t\t: null;\n\t\tconst stateId = `${objId}.color`;\n\t\tdebounce(\n\t\t\tstateId,\n\t\t\t() => updateGroupState(stateId, commonState),\n\t\t\tdebounceTimeout,\n\t\t);\n\t}\n\t// Try to update the hue state\n\tif (\n\t\trgbBulbs.length > 0 &&\n\t\t(changedStateId == null || changedStateId.endsWith(\"lightbulb.hue\"))\n\t) {\n\t\tconst commonState =\n\t\t\trgbBulbs.length > 0\n\t\t\t\t? getCommonValue(rgbBulbs.map((b) => b.hue))\n\t\t\t\t: null;\n\t\tconst stateId = `${objId}.hue`;\n\t\tdebounce(\n\t\t\tstateId,\n\t\t\t() => updateGroupState(stateId, commonState),\n\t\t\tdebounceTimeout,\n\t\t);\n\t}\n\t// Try to update the saturation state\n\tif (\n\t\trgbBulbs.length > 0 &&\n\t\t(changedStateId == null ||\n\t\t\tchangedStateId.endsWith(\"lightbulb.saturation\"))\n\t) {\n\t\tconst commonState =\n\t\t\trgbBulbs.length > 0\n\t\t\t\t? getCommonValue(rgbBulbs.map((b) => b.saturation))\n\t\t\t\t: null;\n\t\tconst stateId = `${objId}.saturation`;\n\t\tdebounce(\n\t\t\tstateId,\n\t\t\t() => updateGroupState(stateId, commonState),\n\t\t\tdebounceTimeout,\n\t\t);\n\t}\n\t// Try to update the position state\n\tif (\n\t\tgroupBlinds.length > 0 &&\n\t\t(changedStateId == null || changedStateId.endsWith(\"blind.position\"))\n\t) {\n\t\tconst commonState =\n\t\t\tgroupBlinds.length > 0\n\t\t\t\t? getCommonValue(groupBlinds.map((b) => b.position))\n\t\t\t\t: null;\n\t\t// TODO: Assigning null is not allowed as per the node-tradfri-client definitions but it works\n\t\tgroup.position = commonState!;\n\t\tconst stateId = `${objId}.position`;\n\t\tdebounce(\n\t\t\tstateId,\n\t\t\t() => updateGroupState(stateId, commonState),\n\t\t\tdebounceTimeout,\n\t\t);\n\t}\n\t// Try to update the plug on/off state\n\tif (\n\t\tgroupPlugs.length > 0 &&\n\t\t(changedStateId == null || changedStateId.endsWith(\"plug.state\"))\n\t) {\n\t\tconst commonState = getCommonValue(groupPlugs.map((p) => p.onOff));\n\t\t// TODO: Assigning null is not allowed as per the node-tradfri-client definitions but it works\n\t\tgroup.onOff = commonState!;\n\t\tconst stateId = `${objId}.state`;\n\t\tdebounce(\n\t\t\tstateId,\n\t\t\t() => updateGroupState(stateId, commonState),\n\t\t\tdebounceTimeout,\n\t\t);\n\t}\n\t// Try to update the air purifier states\n\tfor (const prop of [\n\t\t\"fanMode\",\n\t\t\"fanSpeed\",\n\t\t\"statusLEDs\",\n\t\t\"controlsLocked\",\n\t] as const) {\n\t\tif (\n\t\t\tgroup instanceof VirtualGroup &&\n\t\t\tgroupAPs.length > 0 &&\n\t\t\t(changedStateId == null ||\n\t\t\t\tchangedStateId.endsWith(`airPurifier.${prop}`))\n\t\t) {\n\t\t\tconst commonState =\n\t\t\t\tgetCommonValue(groupAPs.map((p) => p[prop])) ?? null;\n\t\t\tgroup[prop] = commonState as any;\n\t\t\tconst stateId = `${objId}.${prop}`;\n\t\t\tdebounce(\n\t\t\t\tstateId,\n\t\t\t\t() => updateGroupState(stateId, commonState),\n\t\t\t\tdebounceTimeout,\n\t\t\t);\n\t\t}\n\t}\n}\n\n// gets called when a lightbulb state gets updated\n// we use this to sync group states because those are not advertised by the gateway\nexport function syncGroupsWithState(\n\tid: string,\n\tstate: ioBroker.State | null | undefined,\n): void {\n\tif (state && state.ack) {\n\t\tconst instanceId = getInstanceId(id);\n\t\tif (instanceId == undefined) return;\n\t\tif (instanceId in $.devices && $.devices[instanceId] != null) {\n\t\t\tconst accessory = $.devices[instanceId];\n\t\t\tupdateMultipleGroupStates(accessory, id);\n\t\t}\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
