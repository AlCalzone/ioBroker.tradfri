{
  "version": 3,
  "sources": ["../../src/modules/custom-subscriptions.ts"],
  "sourcesContent": ["import { Global as _ } from \"../lib/global\";\nimport { str2regex } from \"../lib/str2regex\";\n\nexport interface CustomStateSubscription {\n\tpattern: RegExp;\n\tcallback: (id: string, state: ioBroker.State | null | undefined) => void;\n}\nexport interface CustomObjectSubscription {\n\tpattern: RegExp;\n\tcallback: (id: string, obj: ioBroker.Object | null | undefined) => void;\n}\nconst customStateSubscriptions: {\n\tsubscriptions: Map<string, CustomStateSubscription>;\n\tcounter: number;\n} = {\n\tsubscriptions: new Map(),\n\tcounter: 0,\n};\nconst customObjectSubscriptions: {\n\tsubscriptions: Map<string, CustomObjectSubscription>;\n\tcounter: number;\n} = {\n\tsubscriptions: new Map(),\n\tcounter: 0,\n};\n\n/**\n * Ensures the subscription pattern is valid\n */\nfunction checkPattern(pattern: string | RegExp): RegExp | undefined {\n\ttry {\n\t\tif (typeof pattern === \"string\") {\n\t\t\treturn str2regex(pattern);\n\t\t} else if (pattern instanceof RegExp) {\n\t\t\treturn pattern;\n\t\t} else {\n\t\t\t// NOPE\n\t\t\tthrow new Error(\"The pattern must be regex or string\");\n\t\t}\n\t} catch (e) {\n\t\t_.log(\"cannot subscribe with this pattern. reason: \" + e, \"error\");\n\t}\n}\n\nexport function applyCustomStateSubscriptions(\n\tid: string,\n\tstate: ioBroker.State | null | undefined,\n): void {\n\ttry {\n\t\tfor (const sub of customStateSubscriptions.subscriptions.values()) {\n\t\t\tif (\n\t\t\t\tsub &&\n\t\t\t\tsub.pattern &&\n\t\t\t\tsub.pattern.test(id) &&\n\t\t\t\ttypeof sub.callback === \"function\"\n\t\t\t) {\n\t\t\t\t// Wenn die ID zum aktuellen Pattern passt, dann Callback aufrufen\n\t\t\t\tsub.callback(id, state);\n\t\t\t}\n\t\t}\n\t} catch (e) {\n\t\t_.log(\"error handling custom sub: \" + e);\n\t}\n}\n\nexport function applyCustomObjectSubscriptions(\n\tid: string,\n\tobj: ioBroker.Object | null | undefined,\n): void {\n\ttry {\n\t\tfor (const sub of customObjectSubscriptions.subscriptions.values()) {\n\t\t\tif (\n\t\t\t\tsub &&\n\t\t\t\tsub.pattern &&\n\t\t\t\tsub.pattern.test(id) &&\n\t\t\t\ttypeof sub.callback === \"function\"\n\t\t\t) {\n\t\t\t\t// Wenn die ID zum aktuellen Pattern passt, dann Callback aufrufen\n\t\t\t\tsub.callback(id, obj);\n\t\t\t}\n\t\t}\n\t} catch (e) {\n\t\t_.log(\"error handling custom sub: \" + e);\n\t}\n}\n\n/**\n * Subscribe to some ioBroker states\n * @param pattern\n * @param callback\n * @returns a subscription ID\n */\nexport function subscribeStates(\n\tpattern: string | RegExp,\n\tcallback: (id: string, state: ioBroker.State | null | undefined) => void,\n): string | undefined {\n\tconst checkedPattern = checkPattern(pattern);\n\tif (checkedPattern == undefined) return;\n\n\tconst newCounter = ++customStateSubscriptions.counter;\n\tconst id = \"\" + newCounter;\n\n\tcustomStateSubscriptions.subscriptions.set(id, {\n\t\tpattern: checkedPattern,\n\t\tcallback,\n\t});\n\n\treturn id;\n}\n\n/**\n * Release the custom subscription with the given id\n * @param id The subscription ID returned by @link{subscribeStates}\n */\nexport function unsubscribeStates(id: string): void {\n\tif (customStateSubscriptions.subscriptions.has(id)) {\n\t\tcustomStateSubscriptions.subscriptions.delete(id);\n\t}\n}\n\n/**\n * Subscribe to some ioBroker objects\n * @param pattern\n * @param callback\n * @returns a subscription ID\n */\nexport function subscribeObjects(\n\tpattern: string | RegExp,\n\tcallback: (id: string, object: ioBroker.Object | null | undefined) => void,\n): string | undefined {\n\tconst checkedPattern = checkPattern(pattern);\n\tif (checkedPattern == undefined) return;\n\n\tconst newCounter = ++customObjectSubscriptions.counter;\n\tconst id = \"\" + newCounter;\n\n\tcustomObjectSubscriptions.subscriptions.set(id, {\n\t\tpattern: checkedPattern,\n\t\tcallback,\n\t});\n\n\treturn id;\n}\n\n/**\n * Release the custom subscription with the given id\n * @param id The subscription ID returned by @link{subscribeObjects}\n */\nexport function unsubscribeObjects(id: string): void {\n\tif (customObjectSubscriptions.subscriptions.has(id)) {\n\t\tcustomObjectSubscriptions.subscriptions.delete(id);\n\t}\n}\n\n/** Clears all custom subscriptions */\nexport function clearCustomSubscriptions(): void {\n\tcustomStateSubscriptions.subscriptions.clear();\n\tcustomObjectSubscriptions.subscriptions.clear();\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAA4B;AAC5B,uBAA0B;AAU1B,MAAM,2BAGF;AAAA,EACH,eAAe,oBAAI;AAAA,EACnB,SAAS;AAAA;AAEV,MAAM,4BAGF;AAAA,EACH,eAAe,oBAAI;AAAA,EACnB,SAAS;AAAA;AAMV,sBAAsB,SAA8C;AACnE,MAAI;AACH,QAAI,OAAO,YAAY,UAAU;AAChC,aAAO,gCAAU;AAAA,eACP,mBAAmB,QAAQ;AACrC,aAAO;AAAA,WACD;AAEN,YAAM,IAAI,MAAM;AAAA;AAAA,WAET,GAAP;AACD,yBAAE,IAAI,iDAAiD,GAAG;AAAA;AAAA;AAIrD,uCACN,IACA,OACO;AACP,MAAI;AACH,eAAW,OAAO,yBAAyB,cAAc,UAAU;AAClE,UACC,OACA,IAAI,WACJ,IAAI,QAAQ,KAAK,OACjB,OAAO,IAAI,aAAa,YACvB;AAED,YAAI,SAAS,IAAI;AAAA;AAAA;AAAA,WAGX,GAAP;AACD,yBAAE,IAAI,gCAAgC;AAAA;AAAA;AAIjC,wCACN,IACA,KACO;AACP,MAAI;AACH,eAAW,OAAO,0BAA0B,cAAc,UAAU;AACnE,UACC,OACA,IAAI,WACJ,IAAI,QAAQ,KAAK,OACjB,OAAO,IAAI,aAAa,YACvB;AAED,YAAI,SAAS,IAAI;AAAA;AAAA;AAAA,WAGX,GAAP;AACD,yBAAE,IAAI,gCAAgC;AAAA;AAAA;AAUjC,yBACN,SACA,UACqB;AACrB,QAAM,iBAAiB,aAAa;AACpC,MAAI,kBAAkB;AAAW;AAEjC,QAAM,aAAa,EAAE,yBAAyB;AAC9C,QAAM,KAAK,KAAK;AAEhB,2BAAyB,cAAc,IAAI,IAAI;AAAA,IAC9C,SAAS;AAAA,IACT;AAAA;AAGD,SAAO;AAAA;AAOD,2BAA2B,IAAkB;AACnD,MAAI,yBAAyB,cAAc,IAAI,KAAK;AACnD,6BAAyB,cAAc,OAAO;AAAA;AAAA;AAUzC,0BACN,SACA,UACqB;AACrB,QAAM,iBAAiB,aAAa;AACpC,MAAI,kBAAkB;AAAW;AAEjC,QAAM,aAAa,EAAE,0BAA0B;AAC/C,QAAM,KAAK,KAAK;AAEhB,4BAA0B,cAAc,IAAI,IAAI;AAAA,IAC/C,SAAS;AAAA,IACT;AAAA;AAGD,SAAO;AAAA;AAOD,4BAA4B,IAAkB;AACpD,MAAI,0BAA0B,cAAc,IAAI,KAAK;AACpD,8BAA0B,cAAc,OAAO;AAAA;AAAA;AAK1C,oCAA0C;AAChD,2BAAyB,cAAc;AACvC,4BAA0B,cAAc;AAAA;",
  "names": []
}
