{
  "version": 3,
  "sources": ["../../src/modules/message.ts"],
  "sourcesContent": ["import { entries } from \"alcalzone-shared/objects\";\nimport { isArray } from \"alcalzone-shared/typeguards\";\nimport { Accessory, AccessoryTypes } from \"node-tradfri-client\";\nimport { Global as _ } from \"../lib/global\";\nimport { calcGroupName } from \"../lib/iobroker-objects\";\nimport { VirtualGroup } from \"../lib/virtual-group\";\nimport type {\n\tDevice as SendToDevice,\n\tGroup as SendToGroup,\n} from \"./communication\";\nimport { extendVirtualGroup, updateGroupStates } from \"./groups\";\nimport { session as $ } from \"./session\";\n\nexport const onMessage: ioBroker.MessageHandler = async (obj) => {\n\t// responds to the adapter that sent the original message\n\tfunction respond(response: string | Record<string, unknown>) {\n\t\tif (obj.callback)\n\t\t\t_.adapter.sendTo(obj.from, obj.command, response, obj.callback);\n\t}\n\t// some predefined responses so we only have to define them once\n\tconst responses = {\n\t\tACK: { error: null },\n\t\tOK: { error: null, result: \"ok\" },\n\t\tERROR_UNKNOWN_COMMAND: { error: \"Unknown command!\" },\n\t\tMISSING_PARAMETER: (paramName: string) => {\n\t\t\treturn { error: 'missing parameter \"' + paramName + '\"!' };\n\t\t},\n\t\tCOMMAND_RUNNING: { error: \"command running\" },\n\t\tRESULT: (result: unknown) => ({ error: null, result }),\n\t\tERROR: (error: string) => ({ error }),\n\t};\n\t// make required parameters easier\n\tfunction requireParams(...params: string[]): boolean {\n\t\tfor (const param of params) {\n\t\t\tif (!(obj.message && obj.message.hasOwnProperty(param))) {\n\t\t\t\trespond(responses.MISSING_PARAMETER(param));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t// handle the message\n\tif (obj) {\n\t\tswitch (obj.command) {\n\t\t\tcase \"request\": {\n\t\t\t\t// custom CoAP request\n\t\t\t\t// require the path to be given\n\t\t\t\tif (!requireParams(\"path\")) return;\n\n\t\t\t\t// check the given params\n\t\t\t\tconst params = obj.message as any;\n\t\t\t\tparams.method = params.method || \"get\";\n\t\t\t\tif (\n\t\t\t\t\t[\"get\", \"post\", \"put\", \"delete\"].indexOf(params.method) ===\n\t\t\t\t\t-1\n\t\t\t\t) {\n\t\t\t\t\trespond({\n\t\t\t\t\t\terror: `unsupported request method \"${params.method}\"`,\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t_.log(\n\t\t\t\t\t`custom coap request: ${params.method.toUpperCase()} \"${\n\t\t\t\t\t\tparams.path\n\t\t\t\t\t}\"`,\n\t\t\t\t);\n\n\t\t\t\t// wait for the CoAP response and respond to the message\n\t\t\t\tconst resp = await $.tradfri.request(\n\t\t\t\t\tparams.path,\n\t\t\t\t\tparams.method,\n\t\t\t\t\tparams.payload,\n\t\t\t\t);\n\t\t\t\trespond(responses.RESULT(resp));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcase \"addVirtualGroup\": {\n\t\t\t\t// calculate the next ID\n\t\t\t\tconst nextID =\n\t\t\t\t\tMath.max(\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t...Object.keys($.virtualGroups).map((k) => +k),\n\t\t\t\t\t) + 1;\n\t\t\t\t// create the group\n\t\t\t\tconst newGroup = new VirtualGroup(nextID);\n\t\t\t\tnewGroup.name = `virtual group ${nextID}`;\n\t\t\t\t// create the ioBroker objects\n\t\t\t\t$.virtualGroups[nextID] = newGroup;\n\t\t\t\textendVirtualGroup(newGroup);\n\t\t\t\t// and return the id\n\t\t\t\trespond(responses.RESULT(nextID));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcase \"editVirtualGroup\": {\n\t\t\t\t// require the id to be given\n\t\t\t\tif (!requireParams(\"id\")) return;\n\n\t\t\t\t// check the given params\n\t\t\t\tconst params = obj.message as any;\n\t\t\t\tconst id = parseInt(params.id, 10);\n\n\t\t\t\tif (!(id in $.virtualGroups)) {\n\t\t\t\t\trespond({ error: `no virtual group with ID ${id} found!` });\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst group = $.virtualGroups[id];\n\t\t\t\t// Update the device ids\n\t\t\t\tif (params.deviceIDs != null && isArray(params.deviceIDs)) {\n\t\t\t\t\tgroup.deviceIDs = (params.deviceIDs as string[])\n\t\t\t\t\t\t.map((d) => parseInt(d, 10))\n\t\t\t\t\t\t.filter((d) => !isNaN(d));\n\t\t\t\t}\n\t\t\t\t// Change the name\n\t\t\t\tif (typeof params.name === \"string\" && params.name.length > 0) {\n\t\t\t\t\tgroup.name = params.name;\n\t\t\t\t}\n\n\t\t\t\t// save the changes\n\t\t\t\textendVirtualGroup(group);\n\t\t\t\tupdateGroupStates(group);\n\n\t\t\t\trespond(responses.OK);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcase \"deleteVirtualGroup\": {\n\t\t\t\t// require the id to be given\n\t\t\t\tif (!requireParams(\"id\")) return;\n\n\t\t\t\t// check the given params\n\t\t\t\tconst params = obj.message as any;\n\t\t\t\tconst id = parseInt(params.id, 10);\n\n\t\t\t\tif (!(id in $.virtualGroups)) {\n\t\t\t\t\trespond({ error: `no virtual group with ID ${id} found!` });\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst group = $.virtualGroups[id];\n\t\t\t\tconst channel = calcGroupName(group);\n\t\t\t\tawait _.adapter.deleteChannel(channel);\n\t\t\t\tdelete $.virtualGroups[id];\n\n\t\t\t\trespond(responses.OK);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcase \"getGroups\": {\n\t\t\t\t// get all groups defined on the gateway\n\t\t\t\t// check the given params\n\t\t\t\tconst params = obj.message as any;\n\t\t\t\t// group type must be \"real\", \"virtual\" or \"both\"\n\t\t\t\tconst groupType = params.type || \"real\";\n\t\t\t\tif ([\"real\", \"virtual\", \"both\"].indexOf(groupType) === -1) {\n\t\t\t\t\trespond(\n\t\t\t\t\t\tresponses.ERROR(\n\t\t\t\t\t\t\t`group type must be \"real\", \"virtual\" or \"both\"`,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst ret: Record<string, SendToGroup> = {};\n\t\t\t\tif (groupType === \"real\" || groupType === \"both\") {\n\t\t\t\t\tfor (const [id, group] of entries($.groups)) {\n\t\t\t\t\t\tret[id] = {\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\tname: group.group.name,\n\t\t\t\t\t\t\tdeviceIDs: group.group.deviceIDs,\n\t\t\t\t\t\t\ttype: \"real\",\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (groupType === \"virtual\" || groupType === \"both\") {\n\t\t\t\t\tfor (const [id, group] of entries($.virtualGroups)) {\n\t\t\t\t\t\tret[id] = {\n\t\t\t\t\t\t\tid,\n\t\t\t\t\t\t\tname: group.name || \"Unbenannte Gruppe\",\n\t\t\t\t\t\t\tdeviceIDs: group.deviceIDs || [],\n\t\t\t\t\t\t\ttype: \"virtual\",\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trespond(responses.RESULT(ret));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcase \"getDevices\": {\n\t\t\t\t// get all devices defined on the gateway\n\t\t\t\t// check the given params\n\t\t\t\tconst params = obj.message as any;\n\t\t\t\t// device type must be \"lightbulb\", \"plug\" or \"all\"\n\t\t\t\tconst deviceType = params.type || \"all\";\n\t\t\t\tconst allowedDeviceTypes = [\n\t\t\t\t\t\"lightbulb\",\n\t\t\t\t\t\"plug\",\n\t\t\t\t\t\"blind\",\n\t\t\t\t\t\"all\",\n\t\t\t\t];\n\t\t\t\tif (allowedDeviceTypes.indexOf(deviceType) === -1) {\n\t\t\t\t\trespond(\n\t\t\t\t\t\tresponses.ERROR(\n\t\t\t\t\t\t\t`device type must be one of ${allowedDeviceTypes\n\t\t\t\t\t\t\t\t.map((t) => `\"${t}\"`)\n\t\t\t\t\t\t\t\t.join(\", \")}`,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst ret: Record<string, SendToDevice> = {};\n\t\t\t\tconst predicate = ([, device]: [unknown, Accessory]) =>\n\t\t\t\t\tdeviceType === \"all\"\n\t\t\t\t\t\t? allowedDeviceTypes.indexOf(\n\t\t\t\t\t\t\t\tAccessoryTypes[device.type],\n\t\t\t\t\t\t  ) > -1\n\t\t\t\t\t\t: deviceType === AccessoryTypes[device.type];\n\n\t\t\t\tconst selectedDevices = entries($.devices).filter(predicate);\n\t\t\t\tfor (const [id, acc] of selectedDevices) {\n\t\t\t\t\tret[id] = {\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tname: acc.name,\n\t\t\t\t\t\ttype: deviceType,\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\trespond(responses.RESULT(ret));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcase \"getDevice\": {\n\t\t\t\t// get preprocessed information about a device\n\t\t\t\t// require the id to be given\n\t\t\t\tif (!requireParams(\"id\")) return;\n\n\t\t\t\t// check the given params\n\t\t\t\tconst params = obj.message as any;\n\t\t\t\tif (!(params.id in $.devices)) {\n\t\t\t\t\trespond(\n\t\t\t\t\t\tresponses.ERROR(\n\t\t\t\t\t\t\t`device with id ${params.id} not found`,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst device = $.devices[params.id];\n\t\t\t\t// TODO: Do we need more?\n\t\t\t\tconst ret: SendToDevice = {\n\t\t\t\t\tname: device.name,\n\t\t\t\t\ttype: AccessoryTypes[device.type], // type as string\n\t\t\t\t} as any;\n\t\t\t\tif (ret.type === \"lightbulb\") {\n\t\t\t\t\tret.spectrum = device.lightList[0].spectrum;\n\t\t\t\t}\n\t\t\t\trespond(responses.RESULT(ret));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\trespond(responses.ERROR_UNKNOWN_COMMAND);\n\t\t\t\treturn;\n\t\t}\n\t}\n};\n"],
  "mappings": "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",
  "names": []
}
